<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TW/Fluxus</title>
    <link rel="stylesheet" href="css/style.css">
</head>

<body>
    <div class="all">
        <div class="header">
            <header>
                <h1>Linguagem TW/Fluxus</h1>
                <h2>Interpretador básico da linguagem TW/Fluxus</h2>
            </header>
        </div>
        <div class="main">
            <h3>Escreva seu código abaixo:</h3>
            <textarea id="code" cols="30" rows="10" placeholder='{<< "Hello, world!;"}'></textarea>
            <button id="btDisplaySnipets">Snipets &#9660;</button>
            <input type="button" id="btRun" value="Rodar">
            <input type="button" id="btReset" value="Limpar">
            <div class="hide" id="snipets">
                <input type="button" id=";" value=";">
                <input type="button" class="double" id="  " value="&#8677;">
                <input type="button" id='""' value='""'>
                <input type="button" id="?? ->" value="?? ->">
                <input type="button" class="double" id="<<" value="<<">
                <input type="button" class="double" id=">>" value=">>">
                <input type="button" class="double" id="->" value="->">
                <input type="button" id="[]" value="[]">
                <input type="button" id="=" value="=">
                <input type="button" class="double" id="!=" value="!=">
                <input type="button" id="<" value="<">
                <input type="button" id=">" value=">">
                <input type="button" id="\" value="\">
                <input type="button" id="," value=",">
                <input type="button" id="+" value="+">
                <input type="button" id="-" value="-">
                <input type="button" id="*" value="*">
                <input type="button" id="/" value="/">
                <input type="button" id="%" value="%">
                <input type="button" id="|" value="|">
                <input type="button" id="&" value="&">
                <input type="button" id="()" value="()">
                <input type="button" id="$" value="$">
                <input type="button" id="{}" value="{}">
            </div>
            <h3>Resultado:</h3>
            <textarea id="result" cols="30" rows="10" disabled></textarea>
        </div>
        <div class="teaching">
            <article>
                <ol>
                    <h1>TW/Fluxus</h1>
                    <p>
                        TW/Fluxus é uma linguagem imperativa, estruturada e procedural.
                        Os comandos são curtos, baseados em poucos símbolos intuitivos, alguns
                        comuns à outras linguagens. Ela visa simular, de maneira escrita,
                        os fluxogramas.
                    </p>
                    <p>
                        Abaixo mostraremos os comandos básicos e como
                        simular as principais estruturas de seleção, estruturas de repetição e o uso de
                        subrotinas. Os comentários da linguagem ficam em linhas iniciadas por #.
                    </p>
                    <li>
                        <h3>Atribuição, leitura e impressão</h3>
                    </li>
                    <p>
                        Para atribuir, ler e imprimir conteúdo numérico, fazemos dessa
                        forma.
                    </p>
                    <pre>
{
    # Atribui 3 à variável a.
    a = 3;

    # Lê um valor numérico em b.
    >> b;

    # Imprime o valor de a e b separados
    # por um espaço em branco.
    << a, " ", b;
}
                    </pre>
                    <p>
                        Para atribuir, ler e imprimir conteúdo de texto, fazemos da
                        forma abaixo.
                    </p>
                    <pre>
{
    # Atribui "amor" à variável $a.
    $a = "amor";

    # Lê um um conjunto de caracteres em $b.
    >> $b;

    # Imprime o valor de $a e $b separados
    # por um espaço em branco.
    << $a, " ", $b;
}
                    </pre>
                    <p>
                        Algumas manipulações podem ser em variáves com índices.
                        Cada variável numérica pode ter o índice de 0 a 999999.
                        O uso dos índices pode simular um array unidimensional de
                        até 1000000 de elementos ou, por exemplo, um bidimensional de
                        1000 x 1000 ou um tridimensional de 100 x 100 x 100, o
                        que já é um tamanho suficiente para a maioria dos casos.
                    </p>
                    <p>
                        Observe um exemplo de uso de índices em variáveis numéricas.
                    </p>
                    <pre>
{
    A = 1;

    # A[0] é igual a A, logo A passará a ser 2.
    # As variávels não são sensíveis ao caso, 
    # portanto A ou a é a mesma coisa.
    A[0] = 2;

    # Imprime "2 2 2".
    << A, " ", A[0], " ", a;

    # Lê um valor em A[10] após pular
    # linha e escrever "A[10] = ".
    << "\nA[10] = ";
    >> A[10];

    # Imprime o valor de A[10].
    << A[10];
}
                    </pre>
                    <p>
                        As variáveis de texto, quando tratadas com índices,
                        representam caracteres únicos. O maior índice para
                        uma variável de texto é 99999. Ou seja, o tamanho
                        máximo de uma string é 100000.
                    </p>
                    <p>
                        O exemplo abaixo ilustra esses casos.
                    </p>
                    <pre>
{
    # Atribui a palavra "Amor"
    # à variável $a.
    $a = "Amor";

    # Imprime o valor de $a
    # e pula linha.
    << $a, "\n";

    # troca a primeira letra
    # de "Amor" por "E".
    $a[0] = "E";

    # troca a última letra
    # de "Amor" por "s".
    $a[3] = "s";

    # Imprime "Emos".
    << $a;
}
                    </pre>
                    <p>
                        Uma string, quando atribuída ou lida para um caractere, tem apenas
                        sua primeira letra guardada de fato. Expressões numéricas,
                        quando atribuídas a um caractere, se convertem ao caractere
                        de valor ASCII da expressão. Por exemplo:
                    </p>
                    <pre>
{
    # Será interpretado como 'b', 
    # o caractere ASCII de número 98.
    $c[4] = 72 - 65 + 91;
    << $c[4], "\n";

    # Lê apenas o primeiro caractere
    # de uma string em $t[3].
    >> $t[3];

    # Apenas o único caractere
    # de $t será impresso.
    << $t[3], "\n";

    # Apenas o primeiro caractere
    # 'A' será atribuído.
    $b[10] = "Amor";
    << $b[10];
}
                    </pre>
                    <p>
                        As expressões numéricas que são mistas com caracteres
                        só serão impressas na forma numérica, onde o caractere
                        terá seu valor tomado como o da tabela ASCII. Por exemplo:
                    </p>
                    <pre>
{
    # imprime 97 + 61 = 158, pois pois 97 é
    # o valor do caractere 'a' na tabela ASCII.
    << "a" + 61, "\n";

    # Lê uma string em $t.
    >> $t;

    # Imprime a subtração do valor ASCII do primeiro
    # caractere de $t com 12.
    << $t - 12, "\n";

    # Imprime 65 * 2 = 130, pois 65 é o valor ASCII de 'A',
    # primeiro caractere de "Amor".
    << "Amor" * 2;
}
                    </pre>
                    <li>
                        <h3>Desvio direto e desvio condicional</h3>
                    </li>
                    <p>
                        Todo código é composto por uma sequência de declarações finalizadas
                        e separadas por ponto e vírgula (;). Para desviar a execução da
                        sequência e saltar para comandos posteriores ou anteriores no
                        código, podemos fazer isso de forma direta ou condicional marcando
                        rótulos numéricos em posições específicas.
                    </p>
                    <p>
                        O desvio direto (goto) é feito por "-> rótulo", onde rótulo é um número
                        real positivo. Rótulos podem ser acrescentados indefinidamente e serão
                        ignorados pela sequência de execução caso não exista um desvio para eles.
                    </p>
                    <pre>
{
    # Atribui 2 à variável a.
    a = 2;

    # Um rótulo inútil, pois não há desvio para ele.
    23;

    # Desvia para o rótulo 1.
    -> 1;

    # Este comando não será executado. Logo,
    # a não será incrementado para 3.
    a = a + 1;

    # O desvio anterior envia para essa posição com rótulo 1.
    1;

    # Será impresso 2.
    << a;
}
                    </pre>
                    <p>
                        Para o desvio condicional usamos "?expressão lógica? -> rótulo".
                        As expressões lógicas são avaliadas como verdadeira (1) ou falsa (0)
                        e, quando verdadeiras, a execução é desviada para a posição do rótulo.
                        Caso a expressão lógica seja falsa, o código continua na sequência
                        original escrita.
                    </p>
                    <pre>
{
    # Lê um número em a.
    >> a;

    # Se a >= 5, desvia a execução para o rótulo 1.
    ?a >= 5? -> 1;

        # Caso a não seja maior ou igual a 5, imprime
        # seu valor seguido do texto " é menor que 5".
        << a, " é menor que 5";

        # Desvia para o rótulo 2 para 
        # terminar a execução.
        -> 2;
    1;
        # Caso desvie para o rótulo 1, imprime seu
        # valor seguido do texto " é maior ou igual a 5".
        << a, " é maior ou igual a 5";
    2; 
}
                    </pre>
                    <li>
                        <h3>Usando desvios para simular laços de repetição</h3>
                    </li>
                    <p>
                        A combinação dos desvios diretos e condicionais simula tudo
                        que pode ser representado por um fluxograma, onde os rótulos são
                        os nós para onde as setas desviam. Por isso, qualquer estrutura
                        representável por fluxograma pode ser simulada combinando
                        esses dois comandos básicos.
                    </p>
                    <p>
                        Abaixo mostraremos estas representações com comentários linha a linha
                        da mesma implementação, mas na linguagem C.
                    </p>
                    <ol>
                        <li>
                            <h4>Laço do...while:</h4>
                        </li>
                        <img class="small" src="img/dowhile.jpg" alt="fluxograma do...while">
                        <pre>
# Imprime os dígitos de 0 a 9.
#-TW/Fluxus---------#-C----------------------
                    # #include < stdio.h >                           
{                   # int main() {
    i = 0;          #   int i = 0;
                    #
    1;              #   do {
        << i;       #       printf("%d", i);
        i = i + 1;  #       i++;
    ?i < 10? -> 1;  #   } while (i < 10);
}                   # }
                        </pre>
                        <li>
                            <h4>Laço while:</h4>
                        </li>
                        <img class="small" src="img/while.jpg" alt="fluxograma while">
                        <pre>
# Calcula a média de uma quantidade indefinida
# de números com valor de saída (-1).
#-TW/Fluxus---------#-C----------------------
                    # #include < stdio.h >                           
{                   # int main() {
    s = 0;          #   int s = 0;
    i = 0;          #   int i = 0;
                    #   int n;
    >> n;           #   scanf("%d", &n);
    1;              #
    ?n == -1? -> 2; #   while (n != -1) {
        i = i + 1;  #       i++;
        s = s + n;  #       s += n;        
        >> n;       #       scanf("%d", &n);
        -> 1;       #   
    2;              #   }
    << s / i;       #   printf("%d", s / i);
}                   # }
                        </pre>
                        <li>
                            <h4>Laço for:</h4>
                        </li>
                        <img class="small" src="img/for.jpg" alt="fluxograma for">
                        <pre>
# Calcula a média de 10 números.
#-TW/Fluxus-------------#-C----------------------
                        # #include < stdio.h >                           
{                       # int main() {
    s = 0;              #   int s = 0;
                        #   int n, i;
    i = 0;              #
    1; ?i >= 10? -> 2;  #   for (i = 0; i < 10; i++) {
        >> n;           #       scanf("%d", &n);
        s = s + n;      #       s += n;
        i = i + 1;      #       
        -> 1;           #   
    2;                  #   }
    << s / i;           #   printf("%d", s / i);
}                       # }
                        </pre>
                    </ol>
                    <li>
                        <h3>Uso de subrotinas</h3>
                    </li>
                    <p>
                        Todo programa é executado tendo início em "{" e terminando em "}".
                        É possível dividir o código em módulos e chamá-los como subrotinas.
                        O comando necessário para isso é "=> rótulo". Funciona como um desvio,
                        porém, o rótulo de uma subrotina deve estar fora dos limites do programa
                        principal, isto é, após "}". No final de cada subrotina é necessário incluir
                        o comando de retorno "<-" para que a execução volte aos limites do programa principal para o
                            ponto logo após onde a subrotina foi chamada. 
                    </p>
                    <p>
                        Para ilustrar o uso de subrotinas, vamos mostrar um programa que verifica se
                        um número é primo ou composto. Este programa estará em três versões, onde duas delas
                        usam subrotinas com boas práticas.
                    </p>
                    <pre>
# Determina se um número é primo ou não
# sem usar subrotina.
{
    << "TESTE DE PRIMARIDADE\n";
    << "Insira o número: ";
    >> n;
    ?n < 2? -> 4;
    i = 2;
    1;?i * i > n? -> 2;
        ?n % i != 0? -> 3;
            4;
            << n, " não é primo";
            -> 5;
        3;
            i = i + 1;
            -> 1;
    2;
        << n, " é primo";
    5;
}
                    </pre>
                    <p>
                        O trabalho de impressão dos resultados podem ser atribuídos à
                        duas subrotinas distintas. Neste exemplo, uma é chamada no rótulo 100,
                        para imprimir que não é primo, e outra é chamada no rótulo 200, para
                        imprimir que é primo.
                    </p>
                    <pre>
# Determina se um número é primo ou não, chamando
# subrotinas para imprimir os resultados.
{
    << "TESTE DE PRIMARIDADE\n";
    << "Insira o número: ";
    >> n;
    ?n < 2? -> 4;
    i = 2;
    1;?i * i > n? -> 2;
        ?n % i != 0? -> 3;
            4;

            # Chama a subrotina 100.
            => 100;
            -> 5;
        3;
            i = i + 1;
            -> 1;
    2;

        # Chama a subrotina 200.
        => 200;
    5;
}

# Rótulo da subrotina 100.
100;

# Imprime que não é primo.
<< n, " não é primo";

# Retorna par o programa principal.
<-;

# Rótulo da subrotina 200.
200;

# Imprime que é primo.
<< n, " é primo";

# Retorna par o programa principal.
<-;
                    </pre>
                    <p>
                        O próprio processo de verificação de primalidade pode ser feito
                        por uma subrotina. Porém, neste caso, uma variável global
                        deve ser utilizada como forma de comunicação entre o programa principal
                        e a subrotina.
                    </p>
                    <p>
                        Observe no exemplo anterior que os rótulos 100 e 200 foram escolhidos como
                        rótulos de subrotinas. Essa prática de escolher rótulos grandes, dos quais o código
                        principal não ancalçaria, é importante para que não haja sobreposição ou ambiguidade
                        nos desvios do programa.
                    </p>
                    <p>
                        Da mesma forma, toma-se como variáveis globais de entrada e saída das
                        subrotinas as variáveis com índices grandes e significativos, como por
                        exemplo, o índice com o mesmo valor do rótulo da subrotina. Os rótulos
                        internos da implementação da subrotina também devem ser grandes e inatingidos no
                        programa principal. Pode-se usar números concatenados com o rótulo da subrotina.
                        Isso evita o uso inadvertido na subrotina de uma variável do programa principal
                        e vice-versa.
                    </p>
                    <p>
                        Essa prática torna as subrotinas mais portáveis e reutilizáveis em outros códigos.
                        Porém, sempre conheça a implementação das subrotinas feitas por terceiros, para se certificar
                        de que não há conflitos de variáveis com o seu código, pois <strong>TODAS AS VARIÁVELS
                        EM TW/Fluxus SÃO GLOBAIS</strong>.
                    </p>
                    <pre>
# Verifica se um número é primo ou não
# usando uma subrotina de verificação
# com variável global de comunicação.
{
    << "TESTE DE PRIMARIDADE\n";
    << "Insira o número: ";
    >> n;
    p[100] = n;
    => 100;
    ?p[100]? -> 1;
        << n, " não é primo";
        -> 2;
    1;
        << n, " é primo";
    2;
}

# Verifica se um número é primo ou não.
# Entrada em p[100]. (número a ser testado)
# Retorno em p[100]. (1 se for primo e 0 se não for)
# Variável auxiliar i[100].
# Rótulos internos 1100, 2100, 3100 e 4100.

100;
?p[100] < 2? -> 4100;
i[100] = 2;
1100;
?i[100] * i[100] > p[100]? -> 2100;
    ?p[100] % i[100] != 0? -> 3100;
        4100;
        p[100] = 0;
        <-;
    3100;
        i[100] = i[100] + 1;
        -> 1100;
2100;
    p[100] = 1;
    <-;
                    </pre>
                    <li>
                        <h3> TW/Fluxus no terminal</h3>
                    </li>
                    <p>
                        A linguagem TW/Fluxus foi originalmente desenvolvida em C para ser executada
                        no terminal de comandos de uma máquina. Nessa versão, cujo interpretador pode
                        ser baixado <a href="https://github.com/ThiagoToWo/tw">clicando aqui</a>, o arquivo
                        principal é o executável tw.exe. 
                    </p>
                    <p>
                        Abra no terminal a pasta onde se encontra o arquivo tw.exe e execute o comando tw. Irá
                        aparecer no terminal o seguinte texto.
                    </p>
                    <pre>
tw      version: x.x.x
Use: tw < file_path > [< options >]
Options availables:
        c:      print program content text.
        p:      print program content optimized.
        cp:     print text and optimized program content.
                    </pre>
                    <p>
                        Ou seja, para executar um código, você deve digitar "tw" e o endereço do código fonte. É opcional
                        acrescentar após o endereço do arquivo as letras "c" para imprimir o conteúdo do programa
                        por você formatado; "p" para imprimir o conteúdo otimizado do programa sem quebra de linhas, comentários
                        e espaços em branco (a versão que será interpretada); e "cp" para imprimir os dois tipos de conteúdo.
                    </p>
                    <p>
                        Dica: faça uma cópia do arquivo tw.exe para as pastas onde ficarão os códigos fontes.
                        Isso simplifica a entrada do endereço.
                    </p>
                    <p>
                        Outra coisa que é possível fazer usando o TW/Fluxus no terminal é incluir as subrotinas em arquivos
                        diferentes e linkar ou importar elas para o código fonte principal através do símbolo @.
                        Abaixo será dado um exemplo que ilustrará todas essa informações.
                    </p>
                    <ol>
                        <li>
                            <h4>Baixe o interpretador no <a href="https://github.com/ThiagoToWo/tw">link dado</a>.</h4>
                        </li>
                        <img class="natural" src="img/repositorio.jpg" alt="print do repositório">
                        <li>
                           <h4>Crie uma pasta chamada "primos" na área de trabalho e copie o arquivo tw.exe para ela.</h4>
                        </li>
                        <pre>
primos/
    |
    +--- tw.exe
                        </pre>
                        <li>
                            <h4>Crie um arquivo de texto na pasta "primos" e dê o nome de "teste_primos".</h4>
                        </li>
                        <pre>
primos/
    |
    +--- tw.exe
    |
    +--- teste_primos.txt
                        </pre>
                        <p>
                            Observação: TW/Fluxus não possui extensão, pois ele executa interpretando os caracteres
                            presentes no texto do código fonte. Portanto, pode ser .txt, .doc, .rtx ou qualquer outro formato
                            de arquivo de texto. Ou ainda um arquivo sem extensão definida ou criada pelo próprio usuário.
                        </p>
                        <li>
                            <h4>Digite o código abaixo no arquivo de texto "teste_primos".</h4>
                        </li>
                        <pre>
# Determina se um numero eh primo ou nao
# sem usar subrotina.
{
    << "TESTE DE PRIMARIDADE\n";
    << "Insira o numero: ";
    >> n;
    ?n < 2? -> 4;
    i = 2;
    1;?i * i > n? -> 2;
        ?n % i != 0? -> 3;
            4;
            << n, " nao eh primo";
            -> 5;
        3;
            i = i + 1;
            -> 1;
    2;
        << n, " eh primo";
    5;
}
                        </pre>
                        <li>
                            <h4>Abra a pasta "primos" na linha de comandos e execute "tw teste_primos.txt".</h4>
                        </li>
                        <img class="natural" src="img/execucao1.jpg" alt="tw teste_primos.txt">
                        <li>
                            <h4>Execute agora "tw teste_primos.txt c".</h4>
                        </li>
                        <img class="natural" src="img/execucao2.jpg" alt="tw teste_primos.txt c">
                        <p>
                            Observe que aparecerá o conteúdo do código completo com a formatação original.
                        </p>
                        <li>
                            <h4>Execute agora "tw teste_primos.txt p".</h4>
                        </li>
                        <img class="natural" src="img/execucao3.jpg" alt="tw teste_primos.txt p">
                        <p>
                            O interpretador executa o código otimizado verificando cacartere por caractere.
                            Observe que o código está todo em uma única linha entre {}, sem espaço em branco
                            e sem comentários.
                        </p>
                        <li>
                            <h4>Execute agora "tw teste_primos.txt cp".</h4>
                        </li>
                        <img class="natural" src="img/execucao4.jpg" alt="tw teste_primos.txt cp">
                        <p>
                            Com esta opção, os dois formatos de conteúdo do código são mostrados.
                        </p>
                        <p>
                            Os passos abaixo ilustrarão como funciona a linkagem de códigos em arquivos diferentes.
                        </p>
                        <li>
                            <h4>Crie uma subpasta na pasta "primos" e dê o nome de "modulos".</h4>
                        </li>
                        <pre>
primos/
    |
    +--- tw.exe
    |
    +--- teste_primos.txt
    |
    +--- modulos/
                        </pre>
                        <li>
                            <h4>Crie um arquivo de texto dentro da pasta "modulos" chamado "primalidade".</h4>
                        </li>
                        <pre>
primos/
    |
    +--- tw.exe
    |
    +--- teste_primos.txt
    |
    +--- modulos/
            |
            +--- primalidade.txt
                        </pre>
                        <li>
                            <h4>Digite o código abaixo no arquivo de texto "primalidade".</h4>
                        </li>
                        <pre>
# Verifica se um numero eh primo ou nao.
# Entrada em p[100]. (numero a ser testado)
# Retorno em p[100]. (1 se for primo e 0 se nao for)
# Variavel auxiliar i[100].
# Rotulos internos 1100, 2100, 3100 e 4100.
                            
100;
?p[100] < 2? -> 4100;
i[100] = 2;
1100;
?i[100] * i[100] > p[100]? -> 2100;
    ?p[100] % i[100] != 0? -> 3100;
        4100;
        p[100] = 0;
        <-;
    3100;
        i[100] = i[100] + 1;
        -> 1100;
2100;
    p[100] = 1;
    <-;
                        </pre>
                        <p>
                            Essa subrotina 100 acima verifica se o valor atribuído a p[100] é primo ou não. 
                            Ela configura p[100] para 1 caso seja primo e para 0 caso não seja. Deixando essa
                            função separada em um arquivo independente, você pode importá-la em qualquer código
                            que precisar desse tipo de verificação de primalidade.
                        </p>
                        <p>
                            Vamos criar um código para usar esse módulo.
                        </p>
                        <li>
                            <h4>Crie um arquivo de texto dentro da pasta "primos" chamado "teste_primos2".</h4>
                        </li>
                        <pre>
primos/
    |
    +--- tw.exe
    |
    +--- teste_primos.txt
    |
    +--- teste_primos2.txt
    |
    +--- modulos/
            |
            +--- primalidade.txt
                        </pre>
                        <li>
                            <h4>Digite o código abaixo no arquivo de texto "teste_primos2".</h4>
                        </li>
                        <pre>
# Verifica se um numero eh primo ou nao
# usando uma subrotina de verificacao
# com variavel global de comunicacao.
{
    << "TESTE DE PRIMARIDADE\n";
    << "Insira o numero: ";
    >> n;
    p[100] = n;
    => 100;
    ?p[100]? -> 1;
        << n, " nao eh primo";
        -> 2;
    1;
        << n, " eh primo";
    2;
}

# Inclua o link no local onde o codigo
# deveria ficar.
@modulos/primalidade.txt
                        </pre>
                        <p>
                            Como o conteúdo do módulo se trata de uma função, ele deve ser incluído após o }.
                            A inclusão do link usando @ em um local, faz com que o interpretador procure o
                            conteúdo desse novo arquivo e escreva nesse local, dando procedimento ao resto do
                            código depois.
                        </p>
                        <p>
                            Vamos executar teste_primos2 usando a opção c para ver como o interpretador completou
                            o código principal com o conteúdo da função 100.
                        </p>
                        <li>
                            <h4>Execute no terminal "tw teste_primos2.txt c".</h4>
                        </li>
                        <img class="natural" src="img/execucao5.jpg" alt="tw teste_primos2.txt c">
                        <p>
                            Reforçamos que, diferente de outras liguagens onde a importação de código é feita no início
                            (cabeçalho), em TW/Fluxus a importação de código é feita no local onde o trecho do arquivo
                            deveria ficar. É como completar um quebra-cabeça.
                        </p>
                        <p>
                            Vamos criar em arquivos separados os comandos de impressão e inclui-los nos locais adequados
                            usando @.
                        </p>
                        <li>
                            <h4>Crie os arquivos de texto dentro da pasta "modulos" chamados "true" e "false".</h4>
                        </li>
                        <pre>
primos/
    |
    +--- tw.exe
    |
    +--- teste_primos.txt
    |
    +--- teste_primos2.txt
    |
    +--- modulos/
            |
            +--- primalidade.txt
            |
            +--- true.txt
            |
            +--- false.txt
                        </pre>
                        <li>
                            <h4>Digite o código abaixo no arquivo de texto "true".</h4>
                        </li>
                        <pre>
<< n, " eh primo";
                        </pre>
                        <p>
                            Tem o único objetivo de imprimir que um número guardado na variável n
                            é primo.
                        </p>
                        <li>
                            <h4>Digite o código abaixo no arquivo de texto "false".</h4>
                        </li>
                        <pre>
<< n, " nao eh primo";
                        </pre>
                        <p>
                            Tem o único objetivo de imprimir que um número guardado na variável n
                            não é primo.
                        </p>
                        <li>
                            <h4>Agora crie um arquivo na pasta "primos" chamado "teste_primos3".</h4>
                        </li>
                        <pre>
primos/
    |
    +--- tw.exe
    |
    +--- teste_primos.txt
    |
    +--- teste_primos2.txt
    |
    +--- teste_primos3.txt
    |
    +--- modulos/
            |
            +--- primalidade.txt
            |
            +--- true.txt
            |
            +--- false.txt
                        </pre>
                        <li>
                            <h4>Digite o código abaixo no arquivo de texto "teste_primos3".</h4>
                        </li>
                        <pre>
# Verifica se um numero eh primo ou nao
# usando uma subrotina de verificacao
# com variavel global de comunicacao.
{
    << "TESTE DE PRIMARIDADE\n";
    << "Insira o numero: ";
    >> n;
    p[100] = n;
    => 100;
    ?p[100]? -> 1;
        @modulos/false.txt
        -> 2;
    1;
        @modulos/true.txt
    2;
}

# Inclua o link no local onde o codigo
# deveria ficar.
@modulos/primalidade.txt
                        </pre>
                        <li>
                            <h4>Execute na linha de comando "tw teste_primos3.txt"</h4>
                        </li>
                        <img class="natural" src="img/execucao6.jpg" alt="tw teste_primos3.txt">
                        <p>
                            Execute o mesmo código com a opção c para ver como o conteúdo dos módulos
                            se encaicham nos locais onde eles foram linkados.
                        </p>
                        <li>
                            <h4>Execute na linha de comando "tw teste_primos3.txt c"</h4>
                        </li>
                        <img class="natural" src="img/execucao7.jpg" alt="tw teste_primos3.txt c">
                    </ol>
                </ol>
            </article>
        </div>
        <div class="definitions">
            <div>
                <h1>LINGUAGEM DE PROGRAMAÇÃO TW/FLUXUS</h1>
                <dl>
                    <dt><i>programa</i>:</dt>
                    <dd>{<i>decl_sequência</i>}</dd>
                    <dt><i>decl_sequência</i>:</dt>
                    <dd><i>declaração</i>; <b>{</b><i>declaração</i>;<b>}</b></dd>
                    <dt><i>declaração</i>:</dt>
                    <dd><i>decl_atribuição</i> <b>|</b></dd>
                    <dd><i>decl_leitura</i> <b>|</b></dd>
                    <dd><i>decl_escrita</i> <b>|</b></dd>
                    <dd><i>decl_condicional</i> <b>|</b></dd>
                    <dd><i>ramificação</i> <b>|</b></dd>
                    <dd><i>subrotina</i> <b>|</b></dd>
                    <dd><i>rótulo</i> <b>|</b></dd>
                    <dd><i>retorno</i></dd>
                    <h2>ENTRADA/SAÍDA:</h2>
                    <dt><i>decl_atribuição</i>:</dt>
                    <dd><i>atrib_numérica</i> <b>|</b></dd>
                    <dd><i>atrib_texto</i></dd>
                    <dt><i>atrib_numérica</i>:</dt>
                    <dd><i>id</i> = <i>expr_lógica</i> <b>{</b>, <i>expr_lógica</i><b>}</b> <b>|</b></dd>
                    <dd><i>id</i>[<i>expr_lógica</i>] = <i>expr_lógica</i> <b>{</b>, <i>expr_lógica</i><b>}</b></dd>
                    <dt><i>atrib_texto</i>:</dt>
                    <dd>$<i>id</i> = "<i>CADEIA</i>" <b>|</b></dd>
                    <dd>$<i>id</i>[<i>expr_lógica</i>] = <i>expr_lógica</i></dd>
                    <dt><i>decl_leitura</i>:</dt>
                    <dd>>> <i>container</i> <b>{</b>, <i>container</i><b>}</b></dd>
                    <dt><i>container</i>:</dt>
                    <dd><i>id</i> <b>|</b></dd>
                    <dd><i>id</i>[<i>expr_lógica</i>] <b>|</b></dd>
                    <dd>$<i>id</i> <b>|</b></dd>
                    <dd>$<i>id</i>[<i>expr_lógica</i>]</dd>
                    <dt><i>decl_escrita</i>:</dt>
                    <dd>
                        << <i>sintagma</i> <b>{</b>, <i>sintagma</i><b>}</b>
                    </dd>
                    <dt><i>sintagma</i>:</dt>
                    <dd>"<i>CADEIA</i>" <b>|</b></dd>
                    <dd>$<i>id</i> <b>|</b></dd>
                    <dd>$<i>id</i>[<i>expr_lógica</i>] <b>|</b></dd>
                    <dd><i>expr_lógica</i></dd>
                    <dt><i>id</i>:</dt>
                    <dd><i>LETRA</i></dd>
                    <h2>COMANDOS:</h2>
                    <dt><i>decl_condicional</i>:</dt>
                    <dd>?<i>expr_lógica</i>? <i>ramificação</i></dd>
                    <dt><i>ramificação</i>:</dt>
                    <dd>-> <i>rótulo</i></dd>
                    <dt><i>subrotina</i>:</dt>
                    <dd>=> <i>rótulo</i></dd>
                    <dt><i>rótulo</i>:</dt>
                    <dd><i>NÚMERO_POSITIVO</i></dd>
                    <dt><i>retorno</i>:</dt>
                    <dd><- </dd>
                    <h2>CÁLCULOS:</h2>
                    <dt><i>expr_lógica</i>:</dt>
                    <dd><i>expr_log_termo</i> <b>{</b><i>disjunção</i> <i>expr_log_termo</i><b>}</b></dd>
                    <dt><i>disjunção</i>:</dt>
                    <dd>|</dd>
                    <dt><i>expr_log_termo</i>:</dt>
                    <dd><i>expr_log_fator</i> <b>{</b><i>conjunção</i> <i>expr_log_fator</i><b>}</b></dd>
                    <dt><i>conjunção</i>:</dt>
                    <dd>&</dd>
                    <dt><i>expr_log_fator</i>:</dt>
                    <dd><i>expr_relacional</i> <b>[</b><i>igualdade</i> <i>expr_relacional</i><b>]</b></dd>
                    <dt><i>igualdade</i>:</dt>
                    <dd>== <b>|</b></dd>
                    <dd>!=</dd>
                    <dt><i>expr_relacional</i>:</dt>
                    <dd><i>expr_simples</i> <b>[</b><i>desigualdade</i> <i>expr_simples</i><b>]</b></dd>
                    <dt><i>desigualdade</i>:</dt>
                    <dd>
                        < <b>|</b>
                    </dd>
                    <dd>> <b>|</b></dd>
                    <dd>
                        <= <b>|</b>
                    </dd>
                    <dd>>=</dd>
                    <dt><i>expr_simples</i>:</dt>
                    <dd><i>termo</i> <b>{</b><i>soma</i> <i>termo</i><b>}</b></dd>
                    <dt><i>soma</i>:</dt>
                    <dd>+ <b>|</b></dd>
                    <dd>-</dd>
                    <dt><i>termo</i>:</dt>
                    <dd><i>fator</i> <b>{</b><i>mult</i> <i>fator</i><b>}</b></dd>
                    <dt><i>mult</i>:</dt>
                    <dd>* <b>|</b></dd>
                    <dd>/ <b>|</b></dd>
                    <dd>%</dd>
                    <dt><i>fator</i>:</dt>
                    <dd>(<i>expr_lógica</i>) <b>|</b></dd>
                    <dd><i>NÚMERO</i> <b>|</b></dd>
                    <dd><i>id</i> <b>|</b></dd>
                    <dd><i>id</i>[<i>expr_lógica</i>] <b>|</b></dd>
                    <dd>"<i>LETRA</i>" <b>|</b></dd>
                    <dd>$<i>id</i> <b>|</b></dd>
                    <dd>$<i>id</i>[<i>expr_lógica</i>]</dd>
                    <h2>MARCAÇõES:</h2>
                    <dt><i>comentários</i>:</dt>
                    <dd>#<i>texto_do_comentário</i> <i>quebra_de_linha</i></dd>
                </dl>
            </div>
        </div>
        <div class="clear"></div>
        <div class="footer">
            <footer>
                <small>Por Thiago Alves - 2023 &copy; Todos os direitos reservados</small>
            </footer>
        </div>
    </div>
    <script src="js/globals.js"></script>
    <script src="js/util.js"></script>
    <script src="js/tw.js"></script>
    <script src="js/main.js"></script>
</body>

</html>